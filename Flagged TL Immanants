import sage.combinat.permutation as permutation

###generates flagged Jacobi-Trudi matrix
Sym = SymmetricFunctions(QQ)
H = Sym.homogeneous()
R=PolynomialRing(QQ, 3,'x')
k = KeyPolynomials(R)
x=R.gens()
    
def f(l,m,b,i,j):
  if l[i]-m[j]>0:
    if b[i]>1:
      return H[l[i]-m[j]].expand(b[i])
    else:
      return x[0]^(l[i]-m[j])
  if l[i]-m[j]==0:
      return 1
  else:
      return 0

def gen(l,m,b):
  N=len(l)
  A=matrix(N,N,lambda i, j: f(l,m,b,i,j))
  return A

###given w,v\in Sym(n), computes f_w(v)
S=SymmetricGroupAlgebra(QQ, 3)
G=SymmetricGroup(3)
s=G.simple_reflections()
Alg=TemperleyLiebAlgebra(3,2,QQ)

def genTL(i):
    d=[]
    d.append([i,i+1])
    d.append([-i,-(i+1)])
    return Alg(d)

#iterates through red, computes element prod (t_i-1) in the group algebra
#then iterates through product to find coefficient on T_w
#input w just as a list and v as an element of G
def F(w,v):
  red=v.reduced_word()
  prod=1
  for i in red:
    prod=Alg((genTL(i)-1)*prod)
  if type(prod)==Integer:
    if S(w)==1:
        return prod
    else:
        return 0
  p=Alg(w)
  D=prod._monomial_coefficients
  for key in D:
      if Alg(key) == p:
          return D.get(key)
  return 0

def Imm(w,X,n):
  imm=0
  for v in G:
    prod=F(w,v)
    for i in range(n):
      prod=prod*X[i][v(i+1)-1]
    imm=imm+prod
  return imm

l=[4,3,3]
m=[3,2,1]
b=[1,2,3]
X=gen(l,m,b)
w=[1,2,3]
v=G([2,3,1])
    
print(F(w,v))

#g=k.from_polynomial(g)

